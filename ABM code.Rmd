---
title: "SocCult/CompMod ABM"
output: html_document
---

```{r setup, include=FALSE}

pacman::p_load(ggplot2, dplyr, ggpubr, lme4, wesanderson, haven, cars, scales)

```


##### NORMAL MODEL #####


```{r}

set.seed(8675309)

simplemodel  <- function(N, t_max, r_max, mean, sd) {

  
  # Create output tibble
  output <- tibble(generation = rep(1:t_max, r_max),
                   run = as.factor(rep(1:r_max, each = t_max)),
                   O = as.numeric(rep(NA, t_max * r_max)), 
                   W = as.numeric(rep(NA, t_max * r_max)),
                   M = as.numeric(rep(NA, t_max * r_max)),
                   B = as.numeric(rep(NA, t_max * r_max)),
                   s = as.numeric(rep(NA, t_max*r_max)),
                   E = as.numeric(rep(NA, t_max * r_max)),
                   sd = as.numeric(rep(NA, t_max*r_max)))
  

  
  
  for (r in 1:r_max) {
    
    # Create a population. replace = t means they can have same openness
    population <- tibble(behaviour = ((sample(10:100, N, replace = TRUE))/100),
                         free_enrg = rep(NA, N),
                         change = rep(NA,N),
                         openness = (rnorm(1000, mean, sd)),
                         fitness = rep(NA, N),
                         copyprob = rep(NA, N),
                         status = rep(1,N),
                         group = rep(NA,N),
                         meanopenness = rep(NA,N))
    
    
    # Initialise the environment and entropy
    E <- (sample(10:100,1)/100)
    S <- (1)
  

  for (t in 1:t_max) {

     options(dplyr.summarise.inform = FALSE)
    
    
    #####MEETING IN GROUPS######
    
   population$group <- rep(1:(N/5), times = 5)
   
  
  
    ##OPENNESS CHANGE####
  
    
     groupmean <- population %>% group_by(group) %>% summarise(meanopenness = mean(openness)) 
      
     groupmeans <- rep(groupmean$meanopenness, times = 5) #again, 5 is group size here

    population$meanopenness <- groupmeans
      
      population$opendirection <- ifelse(population$openness > population$meanopenness, -1, 1)
      
     population$openness <- population$openness+((population$openness*(sample(0:100, 1)/1000))*population$opendirection)

    
      ##### 1. 
     # CHANGING BEHAVIOR AFTER ENVIRONMENT 
      population$free_enrg <- sqrt((E - population$behaviour)^2)
      
      population$change <- sqrt((population$free_enrg * population$openness)^2)
      
      population$previous_behaviour <- population$behaviour

    ####NEW BEHAVIOR MOVING TOWARD ENVIRONMET
      
     population$direction <- ifelse(population$previous_behaviour > E, -1, 1)

    population$behaviour <- population$previous_behaviour +  population$change*population$direction
    
    
    population$upddiff <- sqrt((E - population$behaviour)^2)/100
    

 
    
     
  # 2.   CALCULATE FITNESS

       
  population$fitness <- 1
  
  #energypentalty relative to outer entropy
  
 P <- energypenalty+(energypenalty*(S/100))
  
    population$free_enrg <- population$free_enrg/100
   population$change <- population$change/100
  
    #penalty for prediction error
  population$fitness <- population$fitness - (population$free_enrg*P)
  #penalty for energy for changing
  population$fitness <- population$fitness - (population$change*P)
  #penalty for updated difference
   population$fitness <-  population$fitness - (population$upddiff*P)
  

  
    
   #controlling for negative fitnesses
   
  population$fitness <-  ifelse(population$fitness<0, 0, population$fitness)
 population$fitness <-  population$fitness+1
  
  
  
  
  
   ##status
x = 1
result <- vector(length=length(population$behaviour))
for (num in population$behaviour) {
result[x] <- sum(population$behaviour == num)
x <- x + 1 
}
    
population$status <- result

population$status <- population$status/10
#Status penalty for mental illness/rigidity/social iso

population$status <- population$status-(1-population$openness)
 population$status <- ifelse(population$status<0, 0, population$status)





  
  
   # 4. Store population characteristics in output
      
      output[output$generation == t & output$run == r, ]$W <-mean(population$fitness)
      output[output$generation == t & output$run == r, ]$O <- mean(population$openness)
      output[output$generation == t & output$run == r, ]$M <- E - mean(population$behaviour)
      output[output$generation == t & output$run == r, ]$B <- mean(population$behaviour)
      output[output$generation == t & output$run == r, ]$s <- mean(population$status)
       output[output$generation == t & output$run == r, ]$E <- E
      output[output$generation == t & output$run == r, ]$sd <- sd(population$openness)
 
     
      
      
      # 5. REPRODUCTION
      
      previous_population <- population
      
    
      #copy behaviour based on fitness and status <3 yay
      
      population$openness <- 
      sample(previous_population$openness, size = N, replace = TRUE, prob = previous_population$fitness)
      
  

      #behaviour replication
      
      previous_population$copyprob <- previous_population$fitness+previous_population$status

      population$behaviour <- 
      sample(previous_population$behaviour, size = N, replace = T, prob = previous_population$copyprob)

      
     
      groupmean <- NA
      groupmeans <- NA
      
      

      # 6. Potential environmental change
     E <- E + 1
     S <- S+(0.5*E)
      
  }
  
  }
  # Export data from function
 output
}


normal_data <- simplemodel(N = 1000, t_max = 50, r_max = 50, mean = 0.375, sd = 0.07)


```


##### MODEL VALIDATION ########


```{r}

##importing dataset


path = file.path("/Users/julia/Documents/CogSci/cogcomp/soccom", "NEO_PIR.sav")
NEO = read_sav(path)

mean(NEO$scaledo)

#Scaling the dataset

NEO$scaledo <- NEO$o/300



### SINGLE RUN ###

set.seed(86753)

single_runmodel <- function(N, t_max, energypenalty, mean, sd) {


  lastpop <- tibble(p = as.numeric(1:N, N),
                  openness = as.numeric(rep(NA, N)))
  

  for (t in 1:t_max) {
    
    # Create a population. replace = t means they can have same openness
    population <- tibble(behaviour = ((sample(10:100, N, replace = TRUE))/100),
                         free_enrg = rep(NA, N),
                         change = rep(NA,N),
                         openness = (rnorm(1000, mean, sd)),
                         fitness = rep(NA, N),
                         copyprob = rep(NA, N),
                         status = rep(1,N),
                         group = rep(NA,N),
                         meanopenness = rep(NA,N))
    
    
    # Initialise the environment and entropy
    E <- (sample(10:100,1)/100)
    S <- (1)

     options(dplyr.summarise.inform = FALSE)
    
    
    
 
    
    #####MEETING IN GROUPS######
    
   population$group <- rep(1:(N/5), times = 5)
   
  
  
    ##OPENNESS CHANGE####
  
    
     groupmean <- population %>% group_by(group) %>% summarise(meanopenness = mean(openness)) 
      
     groupmeans <- rep(groupmean$meanopenness, times = 5) #again, 5 is group size here

    population$meanopenness <- groupmeans
      
      population$opendirection <- ifelse(population$openness > population$meanopenness, -1, 1)
      
     population$openness <- population$openness+((population$openness*(sample(0:100, 1)/1000))*population$opendirection)

    
      ##### 1. 
     # CHANGING BEHAVIOR AFTER ENVIRONMENT 
      population$free_enrg <- sqrt((E - population$behaviour)^2)
      
      population$change <- sqrt((population$free_enrg * population$openness)^2)
      
      population$previous_behaviour <- population$behaviour

    ####NEW BEHAVIOR MOVING TOWARD ENVIRONMET
      
     population$direction <- ifelse(population$previous_behaviour > E, -1, 1)

    population$behaviour <- population$previous_behaviour + population$change*population$direction
    
    
    population$upddiff <- sqrt((E - population$behaviour)^2)/100
    

  # 2.   CALCULATE FITNESS

       
  population$fitness <- 1
  
  #energypentalty relative to outer entropy
  
 P <- energypenalty+(energypenalty*(S/100))
  
    population$free_enrg <- population$free_enrg/100
   population$change <- population$change/100
  
    #penalty for prediction error
  population$fitness <- population$fitness - (population$free_enrg*P)
  #penalty for energy for changing
  population$fitness <- population$fitness - (population$change*P)
  #penalty for updated difference
   population$fitness <-  population$fitness - (population$upddiff*P)
  

  
    
   #controlling for negative fitnesses
   
  population$fitness <-  ifelse(population$fitness<0, 0, population$fitness)
   population$fitness <-  population$fitness + 1
  
  

   ##status
      x = 1
      result <- vector(length=length(population$behaviour))
      for (num in population$behaviour) {
      result[x] <- sum(population$behaviour == num)
      x <- x + 1 
      }
          
      population$status <- result
      
      population$status <- population$status/10
    #Status penalty for mental illness/rigidity/social iso

      population$status <-population$status-(1-population$openness)
      population$status <- ifelse(population$status<0, 0, population$status)



   # 4. Store population characteristics in output

       lastpop$openness <- population$openness
  
  
      
      
   # 5. REPRODUCTION
      
      previous_population <- population
      
    
      #copy behaviour based on fitness and status <3 yay
      
          population$openness <- 
          sample(previous_population$openness, size = N, replace = TRUE, prob =    previous_population$fitness)
      
  

      #behaviour replication
      
      previous_population$copyprob <- previous_population$fitness+previous_population$status

      population$behaviour <- 
      sample(previous_population$behaviour, size = N, replace = T, prob = previous_population$copyprob)

      
     
      groupmean <- NA
      groupmeans <- NA
      
      

      # 6. Potential environmental change
     E <- E + 1
     S <- S+(0.5*E)
     
   
      
  }

  # Export data from function
 lastpop
}

set.seed(8675)

singlerun <- single_runmodel(N = 1000, t_max = 50, energypenalty = 1, mean = 0.375, sd = 0.07)




#normality tests 
  shapiro.test(NEO$scaledo)
  sd(NEO$scaledo)
  sd(singlerun$openness)


#comparison
  t.test(NEO$scaledo, singlerun$openness)
  hist(singlerun$openness)
  hist(NEO$scaledo)



  ggdensity(NEO$scaledo, 
            main = "Density plot of observed openness (NEO)",
            xlab = "Openness score")
  
  ggdensity(singlerun$openness, 
            main = "Density plot of simulated openness",
            xlab = "Openness score")
  

  quantile(singlerun$openness)
  shapiro.test(singlerun$openness)


```


########   HYP  1   ########


```{r pressure, echo=FALSE}



set.seed(8675309)

hyp1  <- function(N, t_max, r_max, energypenalty, mean, sd) {

  
  # Create output tibble
  output <- tibble(generation = rep(1:t_max, r_max),
                   run = as.factor(rep(1:r_max, each = t_max)),
                   O = as.numeric(rep(NA, t_max * r_max)), 
                   W = as.numeric(rep(NA, t_max * r_max)),
                   M = as.numeric(rep(NA, t_max * r_max)),
                   B = as.numeric(rep(NA, t_max * r_max)),
                   s = as.numeric(rep(NA, t_max*r_max)),
                   E = as.numeric(rep(NA, t_max * r_max)),
                   sd = as.numeric(rep(NA, t_max*r_max)))
  

  
  
  for (r in 1:r_max) {
    
    # Create a population. replace = t means they can have same openness
    population <- tibble(behaviour = ((sample(10:100, N, replace = TRUE))/100),
                         free_enrg = rep(NA, N),
                         change = rep(NA,N),
                         openness = (rnorm(1000, mean, sd)),
                         fitness = rep(NA, N),
                         copyprob = rep(NA, N),
                         status = rep(1,N),
                         group = rep(NA,N),
                         
                         meanopenness = rep(NA,N))
    
    
    # Initialise the environment and entropy
    E <- (sample(10:100,1)/100)
    S <- (1)
    run <-1
  

  for (t in 1:t_max) {

     options(dplyr.summarise.inform = FALSE)
    
    
    #####MEETING IN GROUPS######
    
   population$group <- rep(1:(N/5), times = 5)
   
  
  
    ##OPENNESS CHANGE####
  
    
     groupmean <- population %>% group_by(group) %>% summarise(meanopenness = mean(openness)) 
      
     groupmeans <- rep(groupmean$meanopenness, times = 5) #again, 5 is group size here

    population$meanopenness <- groupmeans
      
      population$opendirection <- ifelse(population$openness > population$meanopenness, -1, 1)
      
     population$openness <- population$openness+((population$openness*(sample(0:100, 1)/1000))*population$opendirection)

    
      ##### 1. 
     # CHANGING BEHAVIOR AFTER ENVIRONMENT 
      population$free_enrg <- sqrt((E - population$behaviour)^2)
      
      population$change <- sqrt((population$free_enrg * population$openness)^2)
      
      population$previous_behaviour <- population$behaviour

    ####NEW BEHAVIOR MOVING TOWARD ENVIRONMET
      
     population$direction <- ifelse(population$previous_behaviour > E, -1, 1)

    population$behaviour <- population$previous_behaviour + population$change*population$direction
    
    
    population$upddiff <- sqrt((E - population$behaviour)^2)/100
    

 
    
     
  # 2.   CALCULATE FITNESS

       
  population$fitness <- 1
  
  #energypentalty relative to outer entropy
  
 P <- energypenalty+(energypenalty*(S/100))
  
    population$free_enrg <- population$free_enrg/100
   population$change <- population$change/100
  
    #penalty for prediction error
  population$fitness <- population$fitness - (population$free_enrg*P)
  #penalty for energy for changing
  population$fitness <- population$fitness - (population$change*P)
  #penalty for updated difference
   population$fitness <-  population$fitness - (population$upddiff*P)
  

  
    
   #controlling for negative fitnesses
   
  population$fitness <-  ifelse(population$fitness<0, 0, population$fitness)
 population$fitness <-  population$fitness+1
  
  
  
  
  
   ##status
x = 1
result <- vector(length=length(population$behaviour))
for (num in population$behaviour) {
result[x] <- sum(population$behaviour == num)
x <- x + 1 
}
    
population$status <- result

population$status <- population$status/10
#Status penalty for mental illness/rigidity/social iso

population$status <- population$status-(1-population$openness)
 population$status <- ifelse(population$status<0, 0, population$status)





  
  
   # 4. Store population characteristics in output
      
      output[output$generation == t & output$run == r, ]$W <-mean(population$fitness)
      output[output$generation == t & output$run == r, ]$O <- mean(population$openness)
      output[output$generation == t & output$run == r, ]$M <- E - mean(population$behaviour)
      output[output$generation == t & output$run == r, ]$B <- mean(population$behaviour)
      output[output$generation == t & output$run == r, ]$s <- mean(population$status)
      output[output$generation == t & output$run == r, ]$sd <- sd(population$openness)
      output[output$generation == t & output$run == r, ]$E <- E
 
     
      
      
      # 5. REPRODUCTION
      
      previous_population <- population
      
    
      #copy behaviour based on fitness and status <3 yay
      
      population$openness <- 
      sample(previous_population$openness, size = N, replace = TRUE, prob = previous_population$fitness)
      
  

      #behaviour replication
      
      previous_population$copyprob <- previous_population$fitness+previous_population$status

      population$behaviour <- 
      sample(previous_population$behaviour, size = N, replace = T, prob = previous_population$copyprob)

      
     
      groupmean <- NA
      groupmeans <- NA
      
      

      # 6. Potential environmental change
     run <- run+1 
     E <- E + ifelse(run == 30, 10, 1)
     S <- S+(0.5*E)
      
  }
  
  }
  # Export data from function
 output
}


#get mean values

quantile(singlerun$openness)

## MODEL CREATION ##
  #Models with sudden change
  
    open_suddenchange <- hyp1(N = 1000, t_max = 50, r_max = 50,  energypenalty = 1, mean = 0.544, sd = 0.07)
    rigid_suddenchange <- hyp1(N = 1000, t_max = 50, r_max = 50, energypenalty = 1, mean = 0.174, sd = 0.07)
    normal_suddenchange <- hyp1(N = 1000, t_max = 50, r_max = 50, energypenalty = 1, mean = 0.375, sd = 0.07)
  
  #without sudden change
  
    model_open <- simplemodel(N = 1000, t_max = 50, r_max = 50,  mean = 0.544, sd = 0.07)
    
    model_rigid <- simplemodel(N = 1000, t_max = 50, r_max = 50, mean = 0.174, sd = 0.07)
  

  model_rigid$population_type <- "Rigid"
  model_open$population_type <- "Open"
  normal_data$population_type <- "Normal"
  
  
  open_suddenchange$population_type <- "Open"
  rigid_suddenchange$population_type <- "Rigid"
  normal_suddenchange$population_type <- "Normal"
  
  


##OUTPUTS###

    mean(model_rigid$W)
    sd(model_rigid$W)
    median(model_rigid$W)
    range(model_rigid$W)
    
    mean(model_open$W)
    sd(model_open$W)
    median(model_open$W)
    range(model_open$W)
    
    mean(normal_data$W)
    sd(normal_data$W)
    median(normal_data$W)
    range(normal_data$W)
    
    mean(rigid_suddenchange$W)
    sd(rigid_suddenchange$W)
    median(rigid_suddenchange$W)
    range(rigid_suddenchange$W)
    
    mean(open_suddenchange$W)
    sd(open_suddenchange$W)
    median(open_suddenchange$W)
    range(open_suddenchange$W)
    
    mean(normal_suddenchange$W)
    sd(normal_suddenchange$W)
    median(normal_suddenchange$W)
    range(normal_suddenchange$W)


  #PLOTS

    hyp1big <- rbind(normal_data, model_open, model_rigid)
    hyp1big$model <- 1
    
    hyp1bigchange <-  rbind(normal_suddenchange, open_suddenchange, rigid_suddenchange)
    hyp1bigchange$model <- 0
    
    plot_multiple_runs_OW(hyp1big)
    plot_multiple_runs_OW(hyp1bigchange)
    
    plot_multiple_runs_W(hyp1big)
    plot_multiple_runs_W(hyp1bigchange)

lastgen <- change_nochange %>% filter(generation == 50)

    plot_multiple_runs_OW(hyp1big)
    plot_multiple_runs_OW(lastgen)

    
    
#single run openness stats

hyp1singleR <- single_runmodel(N = 1000, t_max = 50, energypenalty = 1, mean = 0.174, sd = 0.07)
hyp1singleO <- single_runmodel(N = 1000, t_max = 50, energypenalty = 1, mean = 0.544, sd = 0.07)

## SINGLE RUN STATS ##

    mean(hyp1singleR$openness)
    sd(hyp1singleR$openness)
    median(hyp1singleR$openness)
    range(hyp1singleR$openness)
    
    mean(hyp1singleO$openness)
    sd(hyp1singleO$openness)
    median(hyp1singleO$openness)
    range(hyp1singleO$openness)
    
    mean(singlerun$openness)
    sd(singlerun$openness)
    median(singlerun$openness)
    range(singlerun$openness)



change_nochange <- rbind(hyp1big, hyp1bigchange)

model1 <- lmerTest::lmer(W ~ O + population_type +(1|run), data = change_nochange)
summary(model1)

cor.test(hyp1big$O, hyp1big$W)
cor.test(hyp1bigchange$E, hyp1bigchange$W)


```





######## HYP 2 #######


```{r}


set.seed(8675309)

hyp2 <- function(N, t_max, r_max, energypenalty, cS, cE, mean, sd) {

  
  # Create output tibble
  output <- tibble(generation = rep(1:t_max, r_max),
                   run = as.factor(rep(1:r_max, each = t_max)),
                   O = as.numeric(rep(NA, t_max * r_max)), 
                   W = as.numeric(rep(NA, t_max * r_max)),
                   M = as.numeric(rep(NA, t_max * r_max)),
                   B = as.numeric(rep(NA, t_max * r_max)),
                   s = as.numeric(rep(NA, t_max*r_max)),
                   E = as.numeric(rep(NA, t_max * r_max)),
                   sd = as.numeric(rep(NA, t_max*r_max)))
  

  
  
  for (r in 1:r_max) {
    
    # Create a population. replace = t means they can have same openness
    population <- tibble(behaviour = ((sample(10:100, N, replace = TRUE))/100),
                         free_enrg = rep(NA, N),
                         change = rep(NA,N),
                         openness = (rnorm(1000, mean, sd))/1000,
                         fitness = rep(NA, N),
                         copyprob = rep(NA, N),
                         status = rep(1,N),
                         group = rep(NA,N),
                         meanopenness = rep(NA,N))
    
    
    # Initialise the environment and entropy
    E <- (sample(10:100,1)/100)
    S <- (1)
  

  for (t in 1:t_max) {

     options(dplyr.summarise.inform = FALSE)
    
    
    #####MEETING IN GROUPS######
    
   population$group <- rep(1:(N/5), times = 5)
   
  
  
    ##OPENNESS CHANGE####
  
    
     groupmean <- population %>% group_by(group) %>% summarise(meanopenness = mean(openness)) 
      
     groupmeans <- rep(groupmean$meanopenness, times = 5) #again, 5 is group size here

    population$meanopenness <- groupmeans
      
      population$opendirection <- ifelse(population$openness > population$meanopenness, -1, 1)
      
     population$openness <- population$openness+((population$openness*(sample(0:100, 1)/1000))*population$opendirection)

    
      ##### 1. 
     # CHANGING BEHAVIOR AFTER ENVIRONMENT 
      population$free_enrg <- sqrt((E - population$behaviour)^2)
      
      population$change <- sqrt((population$free_enrg * population$openness)^2)
      
      population$previous_behaviour <- population$behaviour

    ####NEW BEHAVIOR MOVING TOWARD ENVIRONMET
      
    population$direction <- ifelse(population$previous_behaviour > E, -1, 1)

    population$behaviour <- population$previous_behaviour + population$change*population$direction
    
    
    population$upddiff <- sqrt((E - population$behaviour)^2)/100
    

 
    
     
  # 2.   CALCULATE FITNESS

        population$fitness <- 1
  
     #energypentalty relative to outer entropy
  
     P <- energypenalty+(energypenalty*(S/10))
      
    population$free_enrg <- population$free_enrg/100
    population$change <- population$change/100
  
    #penalty for prediction error
    population$fitness <- population$fitness - (population$free_enrg*P)
    #penalty for energy for changing
    population$fitness <- population$fitness - (population$change*P)
    #penalty for updated difference
    population$fitness <-  population$fitness - (population$upddiff*P)
    

  
    
   #controlling for negative fitnesses
   
     population$fitness <-  ifelse(population$fitness<0, 0, population$fitness)
  
     population$fitness <- population$fitness + 1
  
  
  
  
   ##status
      x = 1
      result <- vector(length=length(population$behaviour))
      for (num in population$behaviour) {
      result[x] <- sum(population$behaviour == num)
      x <- x + 1 
      }
          
      population$status <- result
      
      population$status <- population$status/10
  #Status penalty for mental illness/rigidity/social iso

   population$status <-population$status-(1-population$openness)
   population$status <-  ifelse(population$status<0, 0, population$status)





  
   Openness <- population$openness
   # 4. Store population characteristics in output
      
      output[output$generation == t & output$run == r, ]$W <-mean(population$fitness)
      output[output$generation == t & output$run == r, ]$O <- mean(population$openness)
      output[output$generation == t & output$run == r, ]$M <- E - mean(population$behaviour)
      output[output$generation == t & output$run == r, ]$B <- mean(population$behaviour)
      output[output$generation == t & output$run == r, ]$s <- mean(population$status)
      output[output$generation == t & output$run == r, ]$E <- E
 output[output$generation == t & output$run == r, ]$sd <- sd(population$openness)
     
      
      
      # 5. REPRODUCTION
      
      previous_population <- population
      
    
      #copy behaviour based on fitness and status <3 yay
      
      population$openness <- 
      sample(previous_population$openness, size = N, replace = TRUE, prob = previous_population$fitness)
      
  

      #behaviour replication
      
      previous_population$copyprob <- previous_population$fitness+previous_population$status

      population$behaviour <- 
      sample(previous_population$behaviour, size = N, replace = T, prob = previous_population$copyprob)

      
     
      groupmean <- NA
      groupmeans <- NA
      
      

      # 6. Potential environmental change
     E <- E + cE
     S <- S+cS
     
   
      
  }
  
  }
  # Export data from function
 output
}

entr_inc1 <- hyp2(N = 1000, t_max = 50, r_max = 50, energypenalty = 1, cS = 5, cE = 1, mean = 0.375, sd = 0.07)
entr_inc2 <- hyp2(N = 1000, t_max = 50, r_max = 50, energypenalty = 1, cS = 1, cE = 5)
normal_data <- hyp2(N = 1000, t_max = 50, r_max = 50, energypenalty = 1, cS = 2, cE = 2)





hyp3 <- lmerTest::lmer(O ~ S + E + (1|run), data = normal_data)
summary(hyp3)

hyp31 <- lmerTest::lmer(W ~ S + E + (1|run), data = normal_data)
summary(hyp31)


```


######## HYP  3  ########


```{r}


#### GURU MODEL #####

set.seed(8675309)

hyp3 <- function(N, t_max, r_max, energypenalty, mean, sd) {

  
  # Create output tibble
  output <- tibble(generation = rep(1:t_max, r_max),
                   run = as.factor(rep(1:r_max, each = t_max)),
                   O = as.numeric(rep(NA, t_max * r_max)), 
                   W = as.numeric(rep(NA, t_max * r_max)),
                   M = as.numeric(rep(NA, t_max * r_max)),
                   B = as.numeric(rep(NA, t_max * r_max)),
                   s = as.numeric(rep(NA, t_max*r_max)),
                    E = as.numeric(rep(NA, t_max * r_max)),
                   sd = as.numeric(rep(NA, t_max*r_max)))
  

  
  
  for (r in 1:r_max) {
    
    # Create a population. replace = t means they can have same openness
    population <- tibble(behaviour = ((sample(10:100, N, replace = TRUE))/100),
                         free_enrg = rep(NA, N),
                         change = rep(NA,N),
                         openness = (rnorm(1000, mean, sd)),
                         fitness = rep(NA, N),
                         copyprob = rep(NA, N),
                         status = rep(1,N),
                         group = rep(NA,N),
                         meanopenness = rep(NA,N))
    
    
    # Initialise the environment and entropy
    E <- (sample(10:100,1)/100)
    S <- (1)
  

  for (t in 1:t_max) {

     options(dplyr.summarise.inform = FALSE)
    
    ###place gurus
    
     g <- sum(population$openness == 1)
     g2 <- (10-g)
    
    
    ifelse(g < 10, population[1:g2,4] <- 1, population$openness)
    
 
    
    
    
     #####MEETING IN GROUPS######
    
     population$group <- rep(1:(N/5), times = 5)
   
  
  
     ##OPENNESS CHANGE####
  
    
     groupmean <- population %>% group_by(group) %>% summarise(meanopenness = mean(openness)) 
      
     groupmeans <- rep(groupmean$meanopenness, times = 5) #again, 5 is group size here

     population$meanopenness <- groupmeans
      
     population$opendirection <- ifelse(population$openness > population$meanopenness, -1, 1)
      
     population$openness <- population$openness+((population$openness*(sample(0:100, 1)/1000))*population$opendirection)

    
     ##### 1. 
     
    # CHANGING BEHAVIOR AFTER ENVIRONMENT 
      population$free_enrg <- sqrt((E - population$behaviour)^2)
      
      population$change <- sqrt((population$free_enrg * population$openness)^2)
      
      population$previous_behaviour <- population$behaviour

  ####NEW BEHAVIOR MOVING TOWARD ENVIRONMET
      
      population$direction <- ifelse(population$previous_behaviour > E, -1, 1)
  
      population$behaviour <- population$previous_behaviour + population$change*population$direction
      
      
      population$upddiff <- sqrt((E - population$behaviour)^2)/100
      

 
    
     
  # 2. CALCULATE FITNESS

         
    population$fitness <- 1
    
    #energypentalty relative to outer entropy
  
    P <- energypenalty+(energypenalty*(S/100))
    
    population$free_enrg <- population$free_enrg/100
    population$change <- population$change/100
    
    #penalty for prediction error
    population$fitness <- population$fitness - (population$free_enrg*P)
    #penalty for energy for changing
    population$fitness <- population$fitness - (population$change*P)
    #penalty for updated difference
    population$fitness <-  population$fitness - (population$upddiff*P)
  

  
    
  #controlling for negative fitnesses
   
    population$fitness <-  ifelse(population$fitness<0, 0, population$fitness)
  
    population$fitness <- population$fitness + 1
  
  
  
  
  
    ##status
    
     x = 1
     result <- vector(length=length(population$behaviour))
      for (num in population$behaviour) {
        result[x] <- sum(population$behaviour == num)
        x <- x + 1 
        }
          
      population$status <- result
      population$status <-  ifelse(population$openness ==1, 100, population$status)
           
      
      population$status <- population$status/10
      
      #Status penalty for mental illness/rigidity/social iso
      
      population$status <-population$status-(1-population$openness)
      population$status <-  ifelse(population$status<0, 0, population$status)





  
  
      # 4. Store population characteristics in output
      
      output[output$generation == t & output$run == r, ]$W <-mean(population$fitness)
      output[output$generation == t & output$run == r, ]$O <- mean(population$openness)
      output[output$generation == t & output$run == r, ]$M <- E - mean(population$behaviour)
      output[output$generation == t & output$run == r, ]$B <- mean(population$behaviour)
      output[output$generation == t & output$run == r, ]$s <- mean(population$status)
      output[output$generation == t & output$run == r, ]$sd <- sd(population$openness)
             output[output$generation == t & output$run == r, ]$E <- E

 
     
      
      
      # 5. REPRODUCTION
      
      previous_population <- population
      
    
      #copy behaviour based on fitness and status 
      
      population$openness <- 
      sample(previous_population$openness, size = N, replace = TRUE, prob = previous_population$fitness)
      
  

      #behaviour replication
      
      previous_population$copyprob <- previous_population$fitness+previous_population$status

      population$behaviour <- 
      sample(previous_population$behaviour, size = N, replace = T, prob = previous_population$copyprob)

      
     
      groupmean <- NA
      groupmeans <- NA
      
      

     # 6. Potential environmental change
      
     E <- E +  1
     S <- S+(0.5*E)
     
      
  }
  
  }
  # Export data from function
 output
}



model_gurus <- hyp3(N = 1000, t_max = 50, r_max = 50, energypenalty = 1, mean = 0.375, sd = 0.07)



model_gurus$population_type <- "Gurus"
normal_data$population_type <- "No gurus"

hyp4big <-  rbind(model_gurus,normal_data)

plot_boxopen <- function(data_model) {
  ggplot(data = data_model, aes(y = O, x = population_type)) +
    geom_boxplot(aes(color = population_type)) +
     scale_color_manual(values = wes_palette("Cavalcanti1"))+
    theme_bw() +
    labs(y = "Mean population openness", x = "Population type")+
    ggtitle("Mean group openness per population type")
}


plot_boxfitness <- function(data_model) {
  ggplot(data = data_model, aes(y = W, x = population_type)) +
    geom_boxplot(aes( color = population_type)) +
     scale_color_manual(values = wes_palette("Cavalcanti1"))+
    theme_bw() +
    labs(y = "Population mean fitness", x = "Population type")+
    ggtitle("Mean group fitness per population type")
}

  plot_boxopen(hyp4big)
  plot_boxfitness(hyp4big)




 ###STATS 
 
    t.test(normal_data$W, model_gurus$W)
    
    mean(model_gurus$O)
      sd(model_gurus$O)
    
    mean(normal_data$O)
      sd(normal_data$O)
      
  ##SINGLE RUN CHECKS
      ###### SINGLE-RUN GURU CODE ####


#SINGLE RUN

single_runmodel_gurus <- function(N, t_max, energypenalty, mean, sd) {


  lastpop <- tibble(p = as.numeric(1:N, N),
                  openness = as.numeric(rep(NA, N)))
  

  for (t in 1:t_max) {
    
    # Create a population. replace = t means they can have same openness
    population <- tibble(behaviour = ((sample(10:100, N, replace = TRUE))/100),
                         free_enrg = rep(NA, N),
                         change = rep(NA,N),
                         openness = (rnorm(1000, mean, sd)),
                         fitness = rep(NA, N),
                         copyprob = rep(NA, N),
                         status = rep(1,N),
                         group = rep(NA,N),
                         meanopenness = rep(NA,N))
    
    
    # Initialise the environment and entropy
    E <- (sample(10:100,1)/100)
    S <- (1)

     options(dplyr.summarise.inform = FALSE)
    
    
     g <- sum(population$openness == 1)
     g2 <- (10-g)
    
    
    ifelse(g < 10, population[1:g2,4] <- 1, population$openness)
    
 
    
    #####MEETING IN GROUPS######
    
   population$group <- rep(1:(N/5), times = 5)
   
  
  
    ##OPENNESS CHANGE####
  
    
     groupmean <- population %>% group_by(group) %>% summarise(meanopenness = mean(openness)) 
      
     groupmeans <- rep(groupmean$meanopenness, times = 5) #again, 5 is group size here

    population$meanopenness <- groupmeans
      
      population$opendirection <- ifelse(population$openness > population$meanopenness, -1, 1)
      
     population$openness <- population$openness+((population$openness*(sample(0:100, 1)/1000))*population$opendirection)

    
      ##### 1. 
     # CHANGING BEHAVIOR AFTER ENVIRONMENT 
      population$free_enrg <- sqrt((E - population$behaviour)^2)
      
      population$change <- sqrt((population$free_enrg * population$openness)^2)
      
      population$previous_behaviour <- population$behaviour

    ####NEW BEHAVIOR MOVING TOWARD ENVIRONMET
      
     population$direction <- ifelse(population$previous_behaviour > E, -1, 1)

    population$behaviour <- population$previous_behaviour + population$change*population$direction
    
    
    population$upddiff <- sqrt((E - population$behaviour)^2)/100
    

 
    
     
  # 2.   CALCULATE FITNESS

       
  population$fitness <- 1
  
  #energypentalty relative to outer entropy
  
 P <- energypenalty+(energypenalty*(S/100))
  
    population$free_enrg <- population$free_enrg/100
   population$change <- population$change/100
  
    #penalty for prediction error
  population$fitness <- population$fitness - (population$free_enrg*P)
  #penalty for energy for changing
  population$fitness <- population$fitness - (population$change*P)
  #penalty for updated difference
   population$fitness <-  population$fitness - (population$upddiff*P)
  

  
    
   #controlling for negative fitnesses
   
  population$fitness <-  ifelse(population$fitness<0, 0, population$fitness)

  population$fitness <-  population$fitness+1
  
  
  
  
   ##status
x = 1
result <- vector(length=length(population$behaviour))
for (num in population$behaviour) {
result[x] <- sum(population$behaviour == num)
x <- x + 1 
}
    
population$status <- result

population$status <- population$status/10
#Status penalty for mental illness/rigidity/social iso

population$status <-population$status-(1-population$openness)
 population$status <-  ifelse(population$status<0, 0, population$status)





  
  
   # 4. Store population characteristics in output

       lastpop$openness <- population$openness
         
        
 
  
      
      
      # 5. REPRODUCTION
      
      previous_population <- population
      
    
      #copy behaviour based on fitness and status <3 yay
      
      population$openness <- 
      sample(previous_population$openness, size = N, replace = TRUE, prob = previous_population$fitness)
      
  

      #behaviour replication
      
      previous_population$copyprob <- previous_population$fitness+previous_population$status

      population$behaviour <- 
      sample(previous_population$behaviour, size = N, replace = T, prob = previous_population$copyprob)

      
     
      groupmean <- NA
      groupmeans <- NA
      
      

      # 6. Potential environmental change
     E <- E + 1
     S <- S+(0.5*E)
     
   
      
  }

  # Export data from function
 lastpop
}


      singlerunguru <- single_runmodel_gurus(N = 1000, t_max = 50, energypenalty = 1,  mean = 0.375, sd = 0.07)
      
      #hypothesis testing
     
      t.test(NEO$scaledo, singlerunguru$openness)

      mean(singlerunguru$openness)
        sd(singlerunguru$openness)
        median(singlerunguru$openness)
        range(singlerunguru$openness)
      mean(singlerun$openness)
        sd(singlerun$openness)
        median(singlerun$openness)
        range(singlerun$openness)
      mean(NEO$scaledo)
        sd(NEO$scaledo)
        median(NEO$scaledo)
        range(NEO$scaledo)
       
  
plot_multiple_runs_(hyp4big)
        
        
```






```{r}
##PLOT FUNCTIONS###  

plot_multiple_runs_W <- function(data_model) {
  ggplot(data = data_model, aes(y = W, x = generation)) +
    geom_line(aes(colour = population_type)) +
    scale_color_manual(values = wes_palette("Cavalcanti1"))+
    stat_summary(fun = mean, geom = "line", size = 1, aes(colour = population_type)) +
    theme_bw() +
    labs(y = "Mean fitness", x = "Generation")+
    ggtitle("Mean fitness by generation")
}



plot_multiple_runs_O <- function(data_model) {
  ggplot(data = data_model, aes(y = O, x = generation)) +
    geom_line(aes(colour = population_type)) +
    stat_summary(fun = mean, geom = "line", size = 1, col = "black", aes(colour = population_type)) +
    theme_bw() +
    scale_color_manual(values = wes_palette("Cavalcanti1"))+
    labs(y = "mean openness per generation")
}


plot_multiple_runs_OW <- function(hyp1big) {
  ggplot(data = hyp1big, aes(y = W, x = O)) +
    geom_point(aes(colour = population_type)) +
    geom_smooth(method = lm, col = "black") +
    theme_bw() +
    scale_color_manual(values = wes_palette("Cavalcanti1"))+
    labs(y = "Mean fitness", x= "Mean openness")+
    ggtitle("Mean fitness by mean population openness with sudden change")
}


```

